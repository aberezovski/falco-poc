- macro: spawned_process
  condition: (evt.type in (execve, execveat) and evt.dir=<)

- macro: container
  condition: (container.id != host)

- list: shell_binaries
  items: [ash, bash, csh, ksh, sh, tcsh, zsh, dash]

- macro: shell_procs
  condition: (proc.name in (shell_binaries))

- macro: container_entrypoint
  condition: (not proc.pname exists or proc.pname in (runc:[0:PARENT], runc:[1:CHILD], runc, docker-runc, exe, docker-runc-cur, containerd-shim, systemd, crio))

- rule: Terminal shell in container
  desc: >
    A shell was used as the entrypoint/exec point into a container with an attached terminal. Parent process may have 
    legitimately already exited and be null (read container_entrypoint macro). Common when using "kubectl exec" in Kubernetes. 
    Correlate with k8saudit exec logs if possible to find user or serviceaccount token used (fuzzy correlation by namespace and pod name). 
    Rather than considering it a standalone rule, it may be best used as generic auditing rule while examining other triggered 
    rules in this container/tty.
  condition: >
    spawned_process 
    and container
    and shell_procs 
    and proc.tty != 0
    and container_entrypoint
  output: A shell was spawned in a container with an attached terminal (evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline terminal=%proc.tty exe_flags=%evt.arg.flags %container.info)
  priority: NOTICE
  tags: [maturity_stable, container, shell, mitre_execution, T1059]


- list: open_file_dir_event_types
  items: [open, openat]

- list: file_dir_open_programs
  items: [cat, vi, nano]

# - rule: program_accesses_file
#   desc: track whenever a set of programs opens a file
#   condition: >
#     evt.type in (open_file_dir_event_types)
#     and evt.dir=<
#     and proc.name in (file_dir_open_programs)
#   output: a tracked program opened a file (user=%user.name command=%proc.cmdline file=%fd.name)
#   priority: WARNING

- list: common_event_types
  items: [execve, execveat]

- list: common_processes
  items: [bash, sh, ls, rm, sleep]

- macro: k8s_node
  condition: container.id = host

- macro: non_systemd
  condition: not (proc.aname = systemd)

# Falco custom rules collection

- rule: Uncommon Process Execution on K8S Nodes
  desc: Detects execution of an uncommon process
  enabled: true
  condition: >
    k8s_node
    and evt.type in (common_event_types) 
    and evt.dir=< 
    and not proc.name in (common_processes)
    and non_systemd
  output: >
    Unexpected EXECVE process execution: 
    process=%proc.name 
    command=%proc.cmdline 
    parent=%proc.pname 
    path=%proc.cwd 
    ( 
      file=%fd.name 
      gparent=%proc.aname[2] 
      ggparent=%proc.aname[3] 
      gggparent=%proc.aname[4] 
      evt_type=%evt.type 
      user=%user.name 
      user_uid=%user.uid 
      user_loginuid=%user.loginuid 
      user_loginname=%user.loginname 
      process=%proc.name 
      proc_exepath=%proc.exepath 
      parent=%proc.pname 
      command=%proc.cmdline 
      terminal=%proc.tty 
      exe_flags=%evt.arg.flags 
      %container.info
    )
  priority: WARNING

- macro: privileged_access_commands
  condition: proc.aname in (userexec_binaries)

- rule: Privileged actions on K8S Nodes
  desc: Detects execution of privileged actions performed on k8s nodes
  enabled: true
  condition: >
    k8s_node
    and evt.type in (common_event_types)
    and evt.res=SUCCESS 
    and evt.dir=< 
    and not proc.name in (common_processes)
    and privileged_access_commands
  output: >
    Detected privileged action: 
    process=%proc.name
    command=%proc.cmdline 
    path=%proc.cwd 
    event=(%evt.res %evt.rawres %evt.failed)
    ( 
      file=%fd.name
      parent=%proc.pname
      gparent=%proc.aname[2]
      ggparent=%proc.aname[3]
      aname[4]=%proc.aname[4]
      aname[5]=%proc.aname[5]
      aname[6]=%proc.aname[6]
      aname[7]=%proc.aname[7]
      evt_type=%evt.type 
      user=%user.name 
      user_uid=%user.uid 
      user_loginuid=%user.loginuid 
      user_loginname=%user.loginname 
      proc_exepath=%proc.exepath
      terminal=%proc.tty 
      exe_flags=%evt.arg.flags 
      %container.info
    )
  priority: WARNING
  tags: [privileged_actions, host]

# In containers, the user name might be for a uid that exists in the
# container but not on the host. (See
# https://github.com/draios/sysdig/issues/954). So in that case, allow
# a setuid.
- macro: known_user_in_container
  condition: (container and user.name != "N/A")

- macro: somebody_becoming_themselves
  condition: ((user.name=nobody and evt.arg.uid=nobody) or
              (user.name=www-data and evt.arg.uid=www-data) or
              (user.name=_apt and evt.arg.uid=_apt) or
              (user.name=postfix and evt.arg.uid=postfix) or
              (user.name=pki-agent and evt.arg.uid=pki-agent) or
              (user.name=pki-acme and evt.arg.uid=pki-acme) or
              (user.name=nfsnobody and evt.arg.uid=nfsnobody) or
              (user.name=postgres and evt.arg.uid=postgres))

# Add conditions to this macro (probably in a separate file,
# overwriting this macro) to allow for specific combinations of
# programs changing users by calling setuid.
#
# In this file, it just takes one of the condition in the base macro
# and repeats it.
- macro: user_known_non_sudo_setuid_conditions
  condition: (user.name=root)

  # sshd, mail programs attempt to setuid to root even when running as non-root. Excluding here to avoid meaningless FPs
- rule: Non sudo setuid
  enabled: true
  desc: >
    Detect attempts to change users through the use of setuid, with exceptions for sudo/su. 
    The users "root" and "nobody" using setuid on themselves are also excluded, as setuid calls in these cases 
    typically involve reducing privileges. By setting the setuid bit, an attacker could execute code in a 
    different user's context, potentially with higher privileges. One drawback is the potential for noise, 
    as many applications legitimately use this approach.
  condition: >
    k8s_node
    and evt.type=setuid and evt.dir=>
    and not (user.name=root or user.uid=0)
    and not user_known_non_sudo_setuid_conditions
  output: Unexpected setuid call by non-sudo, non-root program (arg_uid=%evt.arg.uid evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline terminal=%proc.tty %container.info)
  priority: NOTICE
  tags: [maturity_incubating, host, container, users, mitre_privilege_escalation, T1548.001]

- list: user_known_chmod_applications
  items: [hyperkube, kubelet, k3s-agent]

- macro: exe_running_docker_save
  condition: >
    (proc.name = "exe"
    and (proc.cmdline contains "/var/lib/docker"
    or proc.cmdline contains "/var/run/docker")
    and proc.pname in (dockerd, docker, dockerd-current, docker-current))

# todo!: the usage of `evt.arg*` filter check in the output should be avoided
# when more than one event type is involved because some event will populate
# the filtercheck and others will always return <NA>. In this specific
# rule, 'chmod' doesn't have a `%evt.arg.fd` argument for example so
# we will always return `<NA>`.
- rule: Set Setuid or Setgid bit
  desc: >
    This rule is focused on detecting the use of setuid or setgid bits set via chmod. These bits, when set for an application, 
    result in the application running with the privileges of the owning user or group. By enabling the setuid or setgid bits, 
    an attacker could run code in a different user's context, possibly with elevated privileges. However, there's a trade-off 
    with noise, given that numerous applications legitimately run chmod. This rule is related to the "Non sudo setuid" rule.
  condition: >
    chmod 
    and (evt.arg.mode contains "S_ISUID" or evt.arg.mode contains "S_ISGID")
    and not proc.name in (user_known_chmod_applications)
    and not exe_running_docker_save
  output: Setuid or setgid bit is set via chmod (fd=%evt.arg.fd filename=%evt.arg.filename mode=%evt.arg.mode evt_type=%evt.type user=%user.name user_uid=%user.uid user_loginuid=%user.loginuid process=%proc.name proc_exepath=%proc.exepath parent=%proc.pname command=%proc.cmdline terminal=%proc.tty %container.info)
  priority:
    NOTICE
  tags: [maturity_incubating, host, container, process, users, mitre_privilege_escalation, T1548.001]
